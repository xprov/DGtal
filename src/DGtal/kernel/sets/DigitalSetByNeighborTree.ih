
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalSetByNeighborTree.ih
 * @author Xavier Provençal (\c xavier.provencalniv-savoie.fr )
 * Laboratoire de Mathématiques (CNRS, UMR 5807), Universitée de Savoie, France
 *
 * @date 21/12/2012
 *
 * Implementation of inline methods defined in DigitalSetByNeighborTree.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
// #include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


std::string indentation( int n )
{
  std::string s("");
  for ( int i=0; i<n; ++i )
    s += " ";
  return s;
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Subclass Tree ------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
Tree()
{
  // Link the roots togheter in other to implement the two's complementary
  // notation.
  for ( unsigned int i=0; i<nb_sons; ++i ) {
      TypeOfSon s(i); // little binary trick, an object of class TypeOfSon is
                      //used in order to simplify bit wise manipulations.
      Point p;
      myRoots[i].initRoot( i );
      for ( unsigned int j=0; j<D; ++j ) {
          bool bit = s.getBit(j);
          p[j] = (bit) ? -1 : 0; // computes the coordinates of the root
          s.flipBit(j); // by flipping the j-th bit, s.intValue becomes the
                        // index of the root that is myRoots[i]'s neighbor amont
                        // the j-th axis.
          if (!bit) 
              myRoots[i].setNeighbor( (2*j)+1, &myRoots[ s.intValue() ] );
          else
              myRoots[i].setNeighbor( 2*j, &myRoots[ s.intValue() ] );
          s.flipBit(j);
          myRoots[i].nextRoot = ( j < D-1 ) ? &myRoots[i+1] : NULL;
      }
      myRoots[i].myPosition = p;
      myNodes.push_back( &myRoots[i] );
  }
  nb_nodes = 0;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
~Tree( )
{
  for ( int i=nb_sons; i<myNodes.size(); ++i )
    {
      delete myNodes[i];
    }
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNeighbor( Node * actual, Direction d )
{
  Node * neighbor = NULL;
  int neighbor_id = d.intValue();
  
  // If a neighboring link has already been build, use it !
  if ( actual->myNeighbors[ neighbor_id ] != NULL )
    {
      neighbor = actual->myNeighbors[ neighbor_id ];
    }
  // Otherwise, it suffices the as the father. This may involve recursion.
  else
    {
      TypeOfSon s = actual->myType;
      int axis = d.axis();
      bool bit = s.getBit( axis );
      s.flipBit( axis ); // s is now the TypeOfSon of the neighbor we're looking for.

      // if this neighbor has the same father
      if ( ( d.positive() && !bit ) || ( d.negative() && bit ) )
        {
          neighbor = getSon( actual->myFather, s );
        }
      else
        {
          // otherwise, use recursion.
          Node * dadsNeighbor = findNeighbor( actual->myFather, d );
          neighbor = getSon( dadsNeighbor, s );
        }
    }
  return neighbor;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getSon( Node * father, TypeOfSon type )
{
  int id = type.intValue();
  if ( father->mySons[ id ] == NULL )
    {
      // TODO replace this 'new' by a NodeHandler that allocates many nodes at once.
      father->mySons[ id ] = new Node();
      father->mySons[ id ]->initNode( father, type );
      myNodes.push_back( father->mySons[ id ] );
      ++nb_nodes;
    }
  return father->mySons[ id ];
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Tree::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Tree]::start\n";
  indent += 2;
  for ( int i=0; i<nb_sons; ++i )
    {
      myRoots[i].selfDisplay( out, indent );
    }
  indent -= 2;
  out << indentation(indent) << "[Tree]::end\n";
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNode( const Point & p, bool add ) 
{
  UnsignedInteger l = depth( p );
  TypeOfSon theTypes[ l ];
  for ( int i=0; i<l; ++i )
    {
      TypeOfSon * t = &theTypes[ (l-1)-i ];
      UnsignedInteger mask = ( 1 << i );
      for ( int k=0; k<D; ++k )
        {
          if ( p[k] & mask )
            t->flipBit( k );
        }
    }
  Node * n = getRoot( p );
  for ( int i=0; i<l; ++i )
    {
      if ( add )
        {
          n = getSon( n, theTypes[ i ] );
        }
      else
        {
          n = n->mySons[ theTypes[ i ].intValue() ];
          if ( n == NULL )
            return NULL;
        }
    } 
  return n;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
addPoint( const Point & p )
{
  Node * n = findNode( p, true );
  if ( n->inTheSet )
    return false;
  n->inTheSet = true;
  return true;

}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
removePoint( const Point & p )
{
  Node * n = findNode( p, false );
  if ( n == NULL )
    return false;
  n->inTheSet = false;
  return true;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( Integer n )
{
  UnsignedInteger N = ( n>=0 ) ? static_cast<UnsignedInteger>( n ) : 
                                 static_cast<UnsignedInteger>( -n )-1;
  UnsignedInteger i = 0;
  // TODO would dichotomia be faster than this loop ?
  while ( ( N >> i ) > 0 )
    ++i;
  return i;
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( const Point & p )
{
  UnsignedInteger dep = 0;
  UnsignedInteger tmp;
  for ( int i=0; i<D; ++i )
    {
      dep = std::max( dep, depth( p[i] ) );
    }
  return dep;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
goDown( Point & pos, TypeOfSon type )
{
  for ( int i=0; i<D; ++i )
    {
      pos[i] = 2*pos[i] + ( ( type.getBit(i) ) ? 1 : 0 );
    }
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
goUp( Point & pos )
{
  for ( int i=0; i<D; ++i )
    {
      pos[i] = ( pos[i] >= 0 ) ? ( pos[i]/2  ) : ( ( pos[i]-1 ) / 2 );
    }
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Root *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getRoot ( const Point & p )
{
  TypeOfSon t;  // start from 0
  for ( int i=0; i<D; ++i )
    {
      if ( p[i] < 0 )   // flip the bits at negative coordinates.
        t.flipBit( i );
    }
  return &myRoots[ t.intValue() ];
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
begin ()
{
  return Iterator( &myRoots[ 0 ] );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
end ()
{
  return Iterator( NULL );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
begin () const
{
  return ConstIterator( &myRoots[ 0 ] );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
end () const
{
  return ConstIterator( NULL );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Node * n ) const
{
  if ( n == NULL )
    return end();
  typename Container::const_iterator itEnd = myNodes.end();
  for ( typename Container::const_iterator it = myNodes.begin();
       it != itEnd; ++it )
    {
      if ( *it == n )
        return it;
    }
  return end();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( Node * n )
{
  return Iterator( n );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Point & p ) const
{
  return ConstIterator( findNode ( p, false ) );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Point & p )
{
  return Iterator( findNode( p, false ) );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
size() const
{
  return nb_nodes;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
computeBoundingBoxRec( Point & lower, Point & upper, const Node * n, 
                       Point & position ) const
{
  if ( n->inside() )
    {
      lower = lower.inf( position );
      upper = upper.sup( position );
    }
  TypeOfSon t;
  for  ( t.type=0; t.type < nb_sons; ++(t.type) )
    {
      if ( ( n->mySons[ t.intValue() ] != NULL )  && ( n->mySons[ t.intValue() ] != n ) )
        {
          goDown( position, t );
          computeBoundingBoxRec( lower, upper, n->mySons[ t.intValue() ], position );
          goUp( position );
        }
    }
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
computeBoundingBox( Point & lower, Point & upper ) const
{
  for  ( int root_id=0; root_id < nb_sons; ++root_id )
    {
      Point p = myRoots[ root_id ].getPosition();
      computeBoundingBoxRec( lower, upper, &myRoots[ root_id ], p );
    }
}

// --------------------------------------------------------------------
// ----------------------- Subclass Root ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Root::
initRoot( unsigned int typeOfRoot )
{
  this->myFather = this;
  this->inTheSet = false;
  for ( int i=0; i<nb_neighbors; ++i )
    this->myNeighbors[i] = NULL;
  for ( int i=0; i<nb_sons; ++i )
    this->mySons[i] = NULL;
  this->myType = TypeOfSon( typeOfRoot );
  this->mySons[ this->myType.intValue() ] = this;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Root::
getPosition( ) const
{
  return myPosition;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Root::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Root]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Position : " << getPosition() << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( this->myNeighbors[i] == NULL )
        out << "null";
      else
        out << this->myNeighbors[i]->getPosition();
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Root]::end\n";
}


// --------------------------------------------------------------------
// ----------------------- Subclass Node ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
initNode( Node * father, TypeOfSon type )
{
  for ( int i=0; i<nb_sons; ++i )
    mySons[i] = NULL;
  for ( int i=0; i<nb_neighbors; ++i )
    myNeighbors[i] = NULL;
  myFather = father;
  myType = type;
  inTheSet = false;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
setNeighbor( int id, Node * n )
{
  myNeighbors[ id ] = n;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getNeighbor ( int id ) const
{
  return myNeighbors[ id ];
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getPosition( ) const
{
  Point p;
  if ( myFather == this )
    return static_cast< const Root* >( this )->getPosition();
  else
    p = myFather->getPosition();
  for ( int i=0; i<D; ++i )
    {
      p[i] *= 2;
      //p[i] += ( myType.intValue() & (1 << i) ) ? 1 : 0 ;
      p[i] += ( myType.getBit( i ) ) ? 1 : 0 ;
    }
  return p;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Node::
inside() const
{
  return inTheSet;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Node::
addToSet() 
{
  inTheSet = true;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Node::
removeFromSet()
{
  inTheSet = false;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Node::
isRoot() const
{
  return ( this == myFather );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node *
DGtal::DigitalSetByNeighborTree<Domain>::Node::
next( Point & pos ) const
{
  Node * next = NULL;
  Node * father = myFather;
  int id = myType.intValue();
  bool needToGoDown = true;

  if ( isRoot() )
    {
      next = static_cast<const Root*>(this)->nextRoot;
      needToGoDown = ( next != NULL );
    }
  else
    {
      // look for a brother
      while ( ( id < nb_sons ) && ( next == NULL ) )
        {
          ++id;
          next = father->mySons[id];
          if ( next == father ) // father is a root, and each root is it's own son.
            {                   
              // this son is skiped since it will the consider later as a father.
              next = NULL; 
            }
        }
      if ( next == NULL )
        {
          next = father;
          needToGoDown = false;
        }
    }

  if ( needToGoDown ) // go down the tree in order to perform a postfix course
    {
      bool allTheWayDown;
      int first_son;
      do 
        {
          allTheWayDown = true;
          first_son = 0;
          while ( ( first_son < nb_sons ) 
                 && ( next->mySons[ first_son ] == NULL ) )
            {
              ++first_son;
            }
          if ( first_son < nb_sons )
            {
              next = next->mySons[ first_son ];
              allTheWayDown = false;
            }
        }
      while ( ! allTheWayDown );
    }
  return next;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Node::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Node]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Type of son : ";
  TypeOfSon t( myType );
  for ( int i=0; i<D; ++i )
    out << t.getBit(i);
  out << ", Coords : " << getPosition() << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( myNeighbors[i] == NULL )
        out << "null";
      else
        out << myNeighbors[i]->getPosition();
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Node]::end\n";
}


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------- Class DigitalSetByNeighborTree ---------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------



// ---------------------------------------------------------------
// ----------------- Standard services ---------------------------
// ---------------------------------------------------------------

/**
 * Destructor.
 */
template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
~DigitalSetByNeighborTree()
{
  delete myTree;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const Domain & d )
  : myDomain( d ), mySize( 0 )
{
  myTree = new Tree();
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const DigitalSetByNeighborTree<Domain> & other )
  : myDomain( other.myDomain )
{ 
  delete myTree;
  myTree = new Tree();
  insertNew( other.begin(), other.end() );
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain> &
DGtal::DigitalSetByNeighborTree<Domain>::
operator= ( const DigitalSetByNeighborTree<Domain> & other )
{
  ASSERT( ( myDomain.lowerBound() <= other.myDomain.lowerBound() )
    && ( myDomain.upperBound() >= other.myDomain.upperBound() )
    && "This domain should include the domain of the other set in case of assignment." );
  delete myTree;
  myTree = new Tree();
  mySize = 0;
  insertNew( other.begin(), other.end() );
  return *this;
}


// ------------------------------------------------------------------------
// ----------------------- Standard Set services --------------------------
// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size
DGtal::DigitalSetByNeighborTree<Domain>::
size() const
{
  return mySize;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::
empty() const
{
  return mySize == 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::
insert( const Point & p )
{
  if ( myTree->addPoint( p ) )
    ++mySize;
}

// ------------------------------------------------------------------------

template <typename Domain>
template <typename PointInputIterator>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insert( PointInputIterator first, PointInputIterator last )
{
  for ( PointInputIterator it = first;
       it != last;
       ++it )
    {
      insert( *it );
    }
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insertNew( const Point & p )
{
  insert( p );
}

// ------------------------------------------------------------------------

template <typename Domain>
template <typename PointInputIterator>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insertNew( PointInputIterator first, PointInputIterator last )
{
  insert( first, last );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( const Point & p )
{
  bool b = myTree->removePoint( p );
  if ( b ) 
    {
      --mySize;
      return 1;
    }
  return 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( Iterator it )
{
  erase( *it );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( Iterator first, Iterator last )
{
  for ( Iterator it = first; it != last; ++it )
    {
      erase( *it );
    }
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
clear()
{
  delete myTree;
  myTree = new Tree();
  mySize = 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
find( const Point & p ) const
{
  typename Tree::ConstIterator it = myTree->find( p );
  return ConstIterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
find( const Point & p )
{
  typename Tree::Iterator it = myTree->find( p );
  return Iterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
begin() const
{
  typename Tree::ConstIterator it = myTree->begin();
  typename Tree::ConstIterator itEnd = myTree->end();
  while ( ( it != itEnd ) && ( ! (*it)->inside() ) )
    {
      ++it;
    }
  return ConstIterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
end() const
{
  return ConstIterator( myTree->end(), myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
begin()
{
  typename Tree::Iterator it = myTree->begin();
  typename Tree::Iterator itEnd = myTree->end();
  while ( ( it != itEnd ) && ( ! (*it)->inside() ) )
    {
      ++it;
    }
  return Iterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
end()
{
  return Iterator( myTree->end(), myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain> &
DGtal::DigitalSetByNeighborTree<Domain>::
operator+=
( const DigitalSetByNeighborTree<Domain> & aSet )
{
  insertNew<ConstIterator>( aSet.begin(), aSet.end() );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::
computeBoundingBox( Point & lower, Point & upper ) const
{
  if ( mySize > 0 )
    {
      for ( int i=0; i<D; ++i )
        {
          lower[ i ] = NumberTraits< Integer >::max();
          upper[ i ] = NumberTraits< Integer >::min();
        }
      myTree->computeBoundingBox( lower, upper );
    }
}

// -----------------------------------------------------------------------
// ------------------- Specific Set services -----------------------------
// -----------------------------------------------------------------------

template <typename Domain>
inline
std::pair< typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator, bool> 
DGtal::DigitalSetByNeighborTree<Domain>::
insertNeighbor( Iterator it, Direction d )
{
  std::pair<Iterator, bool> ret;
  Node *n = *( it.it ); // get the node's adress from the iterator on the tree

  typename Tree::Iterator i = myTree->findNeighbor( n, d );
  ret.first = Iterator( i, myTree  );
  ret.second = (*i)->inside();
  (*i)->addToSet();
  return ret;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::
isNeighborInside( Iterator it, Direction d )
{
  Node *n = *( it.it ); // get the node's adress from the iterator on the tree
  return isNeighborInside( n, d );
  }

// ------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::
isNeighborInside( Node * n, Direction d )
{
  return ( ( n->myNeighborhood[ d.intValue() ] != NULL ) 
         && ( n->myNeighborhood[ d.intValue() ]->inside() ) );
}



// ----------------------------------------------------------------------------
// -------------------- Display services --------------------------------------
// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
displayAllNodes ( std::ostream & out ) const
{
  for ( int i=0; i<nb_sons; ++i )
    {
      out << "Tree rooted on : " << myTree->myRoots[i] << "\n";
    }
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
selfDisplay ( std::ostream & out ) const
{
  out << "[DigitalSetByNeighborTree]::start\n";
  myTree->selfDisplay( out, 2 );
  out << "[DigitalSetByNeighborTree]::end\n";
}



