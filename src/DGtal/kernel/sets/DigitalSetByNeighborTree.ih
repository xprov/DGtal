
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalSetByNeighborTree.ih
 * @author Xavier Provençal (\c xavier.provencalniv-savoie.fr )
 * Laboratoire de Mathématiques (CNRS, UMR 5807), Universitée de Savoie, France
 *
 * @date 21/12/2012
 *
 * Implementation of inline methods defined in DigitalSetByNeighborTree.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
// #include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


std::string indentation( int n )
{
  std::string s("");
  for ( int i=0; i<n; ++i )
    s += " ";
  return s;
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Subclass Tree ------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
Tree()
{
  // Link the roots togheter in other to implement the two's complementary
  // notation.
  for ( unsigned int i=0; i<nb_sons; ++i ) {
      TypeOfSon s(i);
      roots[i].initRoot( i );
      for ( unsigned int j=0; j<D; ++j ) {
          bool bit = s.getBit(j);
          s.flipBit(j);
          if (!bit) 
              roots[i].setNeighbor( (2*j)+1, &roots[ s.intValue() ] );
          else
              roots[i].setNeighbor( 2*j, &roots[ s.intValue() ] );
          s.flipBit(j);
      }
  }
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNeighbor( Node * actual, Direction d )
{
  Node * neighbor = NULL;
  int neighbor_id = d.intValue();

  //std::cout << "[findNeighbor]::debut " << actual << " ";
  //actual->displayPos( std::cout );
  //std::cout << " direction : " << d.d << std::endl;
  
  // If a neighboring link has already been build, use it !
  if ( actual->neighbors[ neighbor_id ] != NULL )
    {
      neighbor = actual->neighbors[ neighbor_id ];
    }
  // Otherwise, it suffices the as the father. This may involve recursion.
  else
    {
      TypeOfSon s = actual->myType;
      int axis = d.axis();
      bool bit = s.getBit( axis );
      s.flipBit( axis ); // s is now the TypeOfSon of the neighbor we're looking for.

      // if this neighbor has the same father
      if ( ( d.positive() && !bit ) || ( d.negative() && bit ) )
        {
          neighbor = getSon( actual->myFather, s );
          //std::cout << "  No recursion, me=" << actual<< " ";
          //actual->displayPos( std::cout );
          //std::cout << "\n             dad=" << actual->myFather << " ";
          //actual->myFather->displayPos( std::cout );
          //std::cout << "             TypeOfSon : " << s.type << "\n";
          //std::cout << "             myNeighbor=" << neighbor << " " ;
          //neighbor->displayPos( std::cout );
          //std::cout << std::endl;
        }
      else
        {
          // otherwise, use recursion.
          Node * dadsNeighbor = findNeighbor( actual->myFather, d );
          neighbor = getSon( dadsNeighbor, s );

          //std::cout << "  Recursion, me=" << actual<< " ";
          //actual->displayPos( std::cout );
          //std::cout << "\n             dad=" << actual->myFather << " ";
          //actual->myFather->displayPos( std::cout );
          //std::cout << "\n             dadsNeighbor=" << dadsNeighbor << " ";
          //dadsNeighbor->displayPos( std::cout );
          //std::cout << "             TypeOfSon : " << s.type << "\n";
          //std::cout << "             myNeighbor=" << neighbor << " ";
          //neighbor->displayPos( std::cout );
          //std::cout << std::endl;
        }
    }
  //std::cout << "[findNeighbor]::fin, me=" << actual << ", neighbor=" << neighbor << std::endl;
  return neighbor;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getSon( Node * father, TypeOfSon type )
{
  int id = type.intValue();
  if ( father->sons[ id ] == NULL )
    {
      Node n;
      // TODO replace this 'new' by a NodeHandler that allocates many nodes at once.
      father->sons[ id ] = new Node();
      father->sons[ id ]->initNode( father, type );
      myNodes.push_back( father->sons[ id ] );
    }
  return father->sons[ id ];
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Tree::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Tree]::start\n";
  indent += 2;
  for ( int i=0; i<nb_sons; ++i )
    {
      roots[i].selfDisplay( out, indent );
    }
  indent -= 2;
  out << indentation(indent) << "[Tree]::end\n";
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNode( const Point & p ) 
{
  //std::cout << "[findNode]::debut " << p << std::endl;
  UnsignedInteger l = depth( p );
  TypeOfSon theTypes[ l ];
  for ( int i=0; i<l; ++i )
    {
      TypeOfSon * t = &theTypes[ (l-1)-i ];
      UnsignedInteger mask = ( 1 << i );
      for ( int k=0; k<D; ++k )
        {
          if ( p[k] & mask )
            t->flipBit( k );
        }
    }
  //for ( int i=0; i<l; ++i )
  //  {
  //    std::cout << theTypes[i].intValue() << " ";
  //  }
  //std::cout << std::endl;
  Node * n = getRoot( p );
  //((Root*)n)->selfDisplay( std::cout );
  for ( int i=0; i<l; ++i )
    {
      n = n->sons[ theTypes[ i ].intValue() ];
      //std::cout << i << ". " << theTypes[i].intValue() << " " << n << std::endl;
      if ( n == NULL )
        return NULL;
      //n->selfDisplay( std::cout, 2 );
    } 
  //std::cout << "[findNode]::fin\n";
  return n;
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( Integer n )
{
  UnsignedInteger N = ( n>=0 ) ? static_cast<UnsignedInteger>( n ) : 
                                 static_cast<UnsignedInteger>( -n )-1;
  UnsignedInteger i = 0;
  // TODO would dichotomia be faster than this loop ?
  while ( ( N >> i ) > 0 )
    ++i;
  return i;
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( Point p )
{
  UnsignedInteger dep = 0;
  UnsignedInteger tmp;
  for ( int i=0; i<D; ++i )
    {
      dep = max( dep, depth( p[i] ) );
    }
  return dep;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Root *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getRoot ( const Point & p )
{
  TypeOfSon t;
  for ( int i=0; i<D; ++i )
    {
      if ( p[i] < 0 )
        t.flipBit( i );
    }
  return &roots[ t.intValue() ];
}


// --------------------------------------------------------------------
// ----------------------- Subclass Root ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Root::
initRoot( unsigned int aTypeOfRoot )
{
  this->myFather = this;
  this->inTheSet = false;
  for ( int i=0; i<nb_neighbors; ++i )
    this->neighbors[i] = NULL;
  for ( int i=0; i<nb_sons; ++i )
    this->sons[i] = NULL;
  this->typeOfRoot = aTypeOfRoot;
  this->myType = TypeOfSon( aTypeOfRoot );
  this->sons[ typeOfRoot ] = this;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Root::
getPosition( ) const
{
  Point p;
  for ( int i=0; i<D; ++i )
    {
      p[i] = ( typeOfRoot & (1 << i) ) ? -1 : 0 ;
    }
  return p;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Root::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Root]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Type of root : ";
  TypeOfSon t( typeOfRoot );
  for ( int i=0; i<D; ++i )
    out << t.getBit(i);
  out << ", Coords : ";
  this->displayPos( out );
  out << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( this->neighbors[i] == NULL )
        out << "null";
      else
        this->neighbors[i]->displayPos( out );
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Root]::end\n";
}


// --------------------------------------------------------------------
// ----------------------- Subclass Node ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
initNode( Node * father, TypeOfSon type )
{
  for ( int i=0; i<nb_sons; ++i )
    sons[i] = NULL;
  for ( int i=0; i<nb_neighbors; ++i )
    neighbors[i] = NULL;
  myFather = father;
  myType = type;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
setNeighbor( int id, Node * n )
{
  neighbors[ id ] = n;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getNeighbor ( int id ) const
{
  return neighbors[ id ];
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getPosition( ) const
{
  Point p;
  if ( myFather == this )
    return static_cast< const Root* >( this )->getPosition();
  else
    p = myFather->getPosition();
  for ( int i=0; i<D; ++i )
    {
      p[i] *= 2;
      p[i] += ( myType.intValue() & (1 << i) ) ? 1 : 0 ;
    }
  return p;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Node::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Node]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Type of son : ";
  TypeOfSon t( myType );
  for ( int i=0; i<D; ++i )
    out << t.getBit(i);
  out << ", Coords : ";
  this->displayPos( out );
  out << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( this->neighbors[i] == NULL )
        out << "null";
      else
        this->neighbors[i]->displayPos( out );
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Node]::end\n";
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Node::
displayPos ( std::ostream & out ) const
{
  Point p = getPosition();
  out << "(" << p[0];
  for ( int i=1; i<D; ++i )
    out << "," << p[i];
  out << ")";
}



// ----------------------------------------------------------------------------
// ----------------------- Standard services ----------------------------------
// ----------------------------------------------------------------------------


/**
 * Destructor.
 */
template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
~DigitalSetByNeighborTree()
{
  std::cout << "Destruction ! " << std::endl;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const Domain & d )
  : myDomain( d )
{
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const DigitalSetByNeighborTree<Domain> & other )
  : myDomain( other.myDomain ), myTree ( other.myTree  )
{ }


// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain> &
DGtal::DigitalSetByNeighborTree<Domain>::
operator= ( const DigitalSetByNeighborTree<Domain> & other )
{
  ASSERT( ( myDomain.lowerBound() <= other.myDomain.lowerBound() )
    && ( myDomain.upperBound() >= other.myDomain.upperBound() )
    && "This domain should include the domain of the other set in case of assignment." );
  myTree  = other.myTree ;
  return *this;
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
displayAllNodes ( std::ostream & out ) const
{
  for ( int i=0; i<nb_sons; ++i )
    {
      out << "Tree rooted on : " << myTree.roots[i] << "\n";

      
    }
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
selfDisplay ( std::ostream & out ) const
{
  out << "[DigitalSetByNeighborTree]::start\n";
  myTree.selfDisplay( out, 2 );
  out << "[DigitalSetByNeighborTree]::end\n";
}


