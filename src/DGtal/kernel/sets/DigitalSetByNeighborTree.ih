
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalSetByNeighborTree.ih
 * @author Xavier Provençal (\c xavier.provencalniv-savoie.fr )
 * Laboratoire de Mathématiques (CNRS, UMR 5807), Universitée de Savoie, France
 *
 * @date 21/12/2012
 *
 * Implementation of inline methods defined in DigitalSetByNeighborTree.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
// #include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


std::string indentation( int n )
{
  std::string s("");
  for ( int i=0; i<n; ++i )
    s += " ";
  return s;
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Subclass Tree ------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
Tree()
{
  // Link the roots togheter in other to implement the two's complementary
  // notation.
  for ( unsigned int i=0; i<nb_sons; ++i ) {
      TypeOfSon s(i); // little binary trick, an object of class TypeOfSon is
                      //used in order to simplify bit wise manipulations.
      Point p;
      myRoots[i].initRoot( i );
      for ( unsigned int j=0; j<D; ++j ) {
          bool bit = s.getBit(j);
          p[j] = (bit) ? -1 : 0; // computes the coordinates of the root
          s.flipBit(j); // by flipping the j-th bit, s.intValue becomes the
                        // index of the root that is myRoots[i]'s neighbor amont
                        // the j-th axis.
          if (!bit) 
              myRoots[i].setNeighbor( (2*j)+1, &myRoots[ s.intValue() ] );
          else
              myRoots[i].setNeighbor( 2*j, &myRoots[ s.intValue() ] );
          s.flipBit(j);
      }
      myRoots[i].myPosition = p;
  }
  nb_nodes = 0;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
~Tree( )
{
  typename Container::iterator itEnd = myNodes.end();
  for ( typename Container::iterator it = myNodes.begin(); 
       it != itEnd; ++it )
    {
      delete *it;
    }
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNeighbor( Node * actual, Direction d )
{
  Node * neighbor = NULL;
  int neighbor_id = d.intValue();
  
  // If a neighboring link has already been build, use it !
  if ( actual->neighbors[ neighbor_id ] != NULL )
    {
      neighbor = actual->neighbors[ neighbor_id ];
    }
  // Otherwise, it suffices the as the father. This may involve recursion.
  else
    {
      TypeOfSon s = actual->myType;
      int axis = d.axis();
      bool bit = s.getBit( axis );
      s.flipBit( axis ); // s is now the TypeOfSon of the neighbor we're looking for.

      // if this neighbor has the same father
      if ( ( d.positive() && !bit ) || ( d.negative() && bit ) )
        {
          neighbor = getSon( actual->myFather, s );
        }
      else
        {
          // otherwise, use recursion.
          Node * dadsNeighbor = findNeighbor( actual->myFather, d );
          neighbor = getSon( dadsNeighbor, s );
        }
    }
  return neighbor;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getSon( Node * father, TypeOfSon type )
{
  int id = type.intValue();
  if ( father->sons[ id ] == NULL )
    {
      // TODO replace this 'new' by a NodeHandler that allocates many nodes at once.
      father->sons[ id ] = new Node();
      father->sons[ id ]->initNode( father, type );
      myNodes.push_back( father->sons[ id ] );
      ++nb_nodes;
    }
  return father->sons[ id ];
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Tree::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Tree]::start\n";
  indent += 2;
  for ( int i=0; i<nb_sons; ++i )
    {
      myRoots[i].selfDisplay( out, indent );
    }
  indent -= 2;
  out << indentation(indent) << "[Tree]::end\n";
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
findNode( const Point & p, bool add ) 
{
  UnsignedInteger l = depth( p );
  TypeOfSon theTypes[ l ];
  for ( int i=0; i<l; ++i )
    {
      TypeOfSon * t = &theTypes[ (l-1)-i ];
      UnsignedInteger mask = ( 1 << i );
      for ( int k=0; k<D; ++k )
        {
          if ( p[k] & mask )
            t->flipBit( k );
        }
    }
  Node * n = getRoot( p );
  for ( int i=0; i<l; ++i )
    {
      if ( add )
        {
          n = getSon( n, theTypes[ i ] );
        }
      else
        {
          n = n->sons[ theTypes[ i ].intValue() ];
          if ( n == NULL )
            return NULL;
        }
    } 
  return n;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
addPoint( const Point & p )
{
  Node * n = findNode( p, true );
  n->inTheSet = true;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
removePoint( const Point & p )
{
  Node * n = findNode( p, false );
  if ( n == NULL )
    return false;
  n->inTheSet = false;
  return true;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( Integer n )
{
  UnsignedInteger N = ( n>=0 ) ? static_cast<UnsignedInteger>( n ) : 
                                 static_cast<UnsignedInteger>( -n )-1;
  UnsignedInteger i = 0;
  // TODO would dichotomia be faster than this loop ?
  while ( ( N >> i ) > 0 )
    ++i;
  return i;
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::UnsignedInteger 
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
depth( Point p )
{
  UnsignedInteger dep = 0;
  UnsignedInteger tmp;
  for ( int i=0; i<D; ++i )
    {
      dep = max( dep, depth( p[i] ) );
    }
  return dep;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Root *
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
getRoot ( const Point & p )
{
  TypeOfSon t;  // start from 0
  for ( int i=0; i<D; ++i )
    {
      if ( p[i] < 0 )   // flip the bits at negative coordinates.
        t.flipBit( i );
    }
  return &myRoots[ t.intValue() ];
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
begin ()
{
  return myNodes.begin();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
end ()
{
  return myNodes.end();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
begin () const
{
  return myNodes.begin();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
end () const
{
  return myNodes.end();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Node * n ) const
{
  if ( n == NULL )
    return end();
  typename Container::const_iterator itEnd = myNodes.end();
  for ( typename Container::const_iterator it = myNodes.begin();
       it != itEnd; ++it )
    {
      if ( *it == n )
        return it;
    }
  return end();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( Node * n )
{
  if ( n == NULL )
    return end();
  typename Container::iterator itEnd = myNodes.end();
  for ( typename Container::iterator it = myNodes.begin();
       it != itEnd; ++it )
    {
      if ( *it == n )
        return it;
    }
  return end();
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::ConstIterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Point & p ) const
{
  Node * n = findNode ( p, false );
  if ( ( n == NULL ) || ( ! n->inside() ) )
    return end();
  else 
    return find( n );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Tree::Iterator
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
find( const Point & p )
{
  Node * n = findNode( p, false );
  if ( ( n == NULL ) || ( ! n->inside() ) )
    return end();
  else
    return find( n );
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size
DGtal::DigitalSetByNeighborTree<Domain>::Tree::
size() const
{
  return nb_nodes;
}

// --------------------------------------------------------------------
// ----------------------- Subclass Root ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Root::
initRoot( unsigned int typeOfRoot )
{
  this->myFather = this;
  this->inTheSet = false;
  for ( int i=0; i<nb_neighbors; ++i )
    this->neighbors[i] = NULL;
  for ( int i=0; i<nb_sons; ++i )
    this->sons[i] = NULL;
  this->myType = TypeOfSon( typeOfRoot );
  this->sons[ this->myType.intValue() ] = this;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Root::
getPosition( ) const
{
  return myPosition;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Root::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Root]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Position : " << getPosition() << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( this->neighbors[i] == NULL )
        out << "null";
      else
        out << this->neighbors[i]->getPosition();
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Root]::end\n";
}


// --------------------------------------------------------------------
// ----------------------- Subclass Node ------------------------------
// --------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
initNode( Node * father, TypeOfSon type )
{
  for ( int i=0; i<nb_sons; ++i )
    sons[i] = NULL;
  for ( int i=0; i<nb_neighbors; ++i )
    neighbors[i] = NULL;
  myFather = father;
  myType = type;
  inTheSet = false;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
setNeighbor( int id, Node * n )
{
  neighbors[ id ] = n;
}


//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Node * 
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getNeighbor ( int id ) const
{
  return neighbors[ id ];
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Point
DGtal::DigitalSetByNeighborTree<Domain>::Node::
getPosition( ) const
{
  Point p;
  if ( myFather == this )
    return static_cast< const Root* >( this )->getPosition();
  else
    p = myFather->getPosition();
  for ( int i=0; i<D; ++i )
    {
      p[i] *= 2;
      p[i] += ( myType.intValue() & (1 << i) ) ? 1 : 0 ;
    }
  return p;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::Node::
inside() const
{
  return inTheSet;
}

//-----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::Node::
selfDisplay ( std::ostream & out, int indent ) const
{
  out << indentation(indent) << "[Node]::start\n";
  indent += 2;
  out << indentation(indent) << "|-> Type of son : ";
  TypeOfSon t( myType );
  for ( int i=0; i<D; ++i )
    out << t.getBit(i);
  out << ", Coords : " << getPosition() << "\n";
  out << indentation(indent) << "|-> Neighbors : ";
  for ( int i=0; i<nb_neighbors; ++i )
    {
      if ( neighbors[i] == NULL )
        out << "null";
      else
        out << neighbors[i]->getPosition();
      out << ", ";
    }
  out << "\n";
  indent -= 2;
  out << indentation(indent) << "[Node]::end\n";
}


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------- Class DigitalSetByNeighborTree ---------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------



// ---------------------------------------------------------------
// ----------------- Standard services ---------------------------
// ---------------------------------------------------------------

/**
 * Destructor.
 */
template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
~DigitalSetByNeighborTree()
{
  delete myTree;
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const Domain & d )
  : myDomain( d ), mySize( 0 )
{
  myTree = new Tree();
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain>::
DigitalSetByNeighborTree( const DigitalSetByNeighborTree<Domain> & other )
  : myDomain( other.myDomain )
{ 
  delete myTree;
  myTree = new Tree();
  insertNew( other.begin(), other.end() );
}


// ----------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain> &
DGtal::DigitalSetByNeighborTree<Domain>::
operator= ( const DigitalSetByNeighborTree<Domain> & other )
{
  ASSERT( ( myDomain.lowerBound() <= other.myDomain.lowerBound() )
    && ( myDomain.upperBound() >= other.myDomain.upperBound() )
    && "This domain should include the domain of the other set in case of assignment." );
  delete myTree;
  myTree = new Tree();
  insertNew( other.begin(), other.end() );
  return *this;
}


// ------------------------------------------------------------------------
// ----------------------- Standard Set services --------------------------
// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size
DGtal::DigitalSetByNeighborTree<Domain>::
size() const
{
  return mySize;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
bool
DGtal::DigitalSetByNeighborTree<Domain>::
empty() const
{
  return mySize == 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void
DGtal::DigitalSetByNeighborTree<Domain>::
insert( const Point & p )
{
  myTree->addPoint( p );
  ++mySize;
}

// ------------------------------------------------------------------------

template <typename Domain>
template <typename PointInputIterator>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insert( PointInputIterator first, PointInputIterator last )
{
  for ( PointInputIterator it = first;
       it != last;
       ++it )
    {
      myTree->addPoint( *it );
    }
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insertNew( const Point & p )
{
  insert( p );
}

// ------------------------------------------------------------------------

template <typename Domain>
template <typename PointInputIterator>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
insertNew( PointInputIterator first, PointInputIterator last )
{
  insert( first, last );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Size 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( const Point & p )
{
  bool b = myTree->removePoint( p );
  if ( b ) 
    {
      --mySize;
      return 1;
    }
  return 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( Iterator it )
{
  erase( *it );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
erase( Iterator first, Iterator last )
{
  for ( Iterator it = first; it != last; ++it )
    {
      erase( *it );
    }
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
void 
DGtal::DigitalSetByNeighborTree<Domain>::
clear()
{
  delete myTree;
  myTree = new Tree();
  mySize = 0;
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
find( const Point & p ) const
{
  typename Tree::ConstIterator it = myTree->find( p );
  return ConstIterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
find( const Point & p )
{
  typename Tree::Iterator it = myTree->find( p );
  return Iterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
begin() const
{
  typename Tree::ConstIterator it = myTree->begin();
  typename Tree::ConstIterator itEnd = myTree->end();
  while ( ( it != itEnd ) && ( ! (*it)->inside() ) )
    {
      ++it;
    }
  return ConstIterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::ConstIterator 
DGtal::DigitalSetByNeighborTree<Domain>::
end() const
{
  return ConstIterator( myTree->end(), myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
begin()
{
  typename Tree::Iterator it = myTree->begin();
  typename Tree::Iterator itEnd = myTree->end();
  while ( ( it != itEnd ) && ( ! (*it)->inside() ) )
    {
      ++it;
    }
  return Iterator( it, myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
typename DGtal::DigitalSetByNeighborTree<Domain>::Iterator 
DGtal::DigitalSetByNeighborTree<Domain>::
end()
{
  return Iterator( myTree->end(), myTree );
}

// ------------------------------------------------------------------------

template <typename Domain>
inline
DGtal::DigitalSetByNeighborTree<Domain> &
DGtal::DigitalSetByNeighborTree<Domain>::
operator+=
( const DigitalSetByNeighborTree<Domain> & aSet )
{
  insertNew<ConstIterator>( aSet.begin(), aSet.end() );
}



// ----------------------------------------------------------------------------
// -------------------- Display services --------------------------------------
// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
displayAllNodes ( std::ostream & out ) const
{
  for ( int i=0; i<nb_sons; ++i )
    {
      out << "Tree rooted on : " << myTree->myRoots[i] << "\n";
    }
}

// ----------------------------------------------------------------------------

template <typename Domain>
inline
void DGtal::DigitalSetByNeighborTree<Domain>::
selfDisplay ( std::ostream & out ) const
{
  out << "[DigitalSetByNeighborTree]::start\n";
  myTree->selfDisplay( out, 2 );
  out << "[DigitalSetByNeighborTree]::end\n";
}



